<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inc√™ndio Florestal</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        header {
            background: #333;
            color: white;
            padding: 20px;
            font-size: 24px;
        }
        canvas {
            border: 1px solid black;
            display: block;
            margin: auto;
        }
        .container {
            max-width: 800px;
            margin: auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        ul {
            text-align: left;
            display: inline-block;
        }
        .diagram {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <header>Modelo: Inc√™ndio Florestal</header>
    <div class="container">
        <p>Agora que j√° aprendemos sobre <a href="jogodavida.html">Aut√¥matos Celulares</a>, podemos modelar um problema da vida real atrav√©s da aplica√ß√£o desses modelos matem√°ticos.</p>
        <p>Inc√™ndios florestais s√£o fen√¥menos que envolvem a propaga√ß√£o descontrolada do fogo em √°reas de vegeta√ß√£o. A problem√°tica desses inc√™ndios est√° em seu enorme poder de devasta√ß√£o, sendo capazes de destruir grandes √°reas, afetar ecossistemas, habitats, causar danos √† sa√∫de p√∫blica e at√© provocar acidentes.</p>
        <p>Modelar inc√™ndios florestais √© interessante, para compreender sua din√¢mica, prever seu comportamento e at√© desenvolver estrat√©gias de combate. </p>

        <h3>Modelando</h3>
        <p>Modelaremos o comportamento de um inc√™ndio florestal, atrav√©s de aut√¥matos celulares, em que o estado de cada c√©lula depende do estado de suas vizinhas.</p>
        <p>Nesse modelo, adotamos uma abordagem estoc√°stica, em que, dado um n√∫mero de vizinhos em chamas, a c√©lula possui uma probabilidade de tamb√©m pegar fogo. Dessa forma, √© poss√≠vel definir diferentes tipos de vegeta√ß√£o com probabilidades distintas de propaga√ß√£o do inc√™ndio (como uma mata seca, onde o fogo se espalha mais rapidamente do que em uma mata √∫mida).</p>
        <p>O aut√¥mato pode ser descrito pelo diagrama abaixo, em que <strong>m</strong> √© o n√∫mero de vizinhos, <strong>œÜ</strong> √© a probabilidade* da c√©lula viva pegar fogo, <strong>Œ∑</strong> √© a probabilidade do fogo se apagar, e <strong>a</strong> √© um n√∫mero aleat√≥rio entre 0 e 1.</p>
        <svg class="diagram" width="400" height="200">
            <!-- Estado c√©lula viva -->
            <circle cx="80" cy="100" r="30" stroke="black" stroke-width="2" fill="lightgreen"></circle>
            <text x="60" y="105" font-size="16" font-family="Arial">Viva</text>
        
            <!-- Estado fogo -->
            <circle cx="220" cy="100" r="30" stroke="black" stroke-width="2" fill="orange"></circle>
            <text x="205" y="105" font-size="16" font-family="Arial">Fogo</text>
        
            <!-- Estado c√©lula queimada -->
            <circle cx="350" cy="100" r="30" stroke="black" stroke-width="2" fill="gray"></circle>
            <text x="315" y="105" font-size="16" font-family="Arial">Queimada</text>
        
            <!-- Setas de transi√ß√£o -->
            <line x1="110" y1="100" x2="190" y2="100" stroke="black" stroke-width="2"></line>
            <polygon points="190,100 180,95 180,105" fill="black"></polygon>
            <text x="80" y="150" font-size="14" font-family="Arial">Œ¥(Viva, m * a > œÜ) ‚Üí Fogo</text>
            
            <line x1="250" y1="100" x2="320" y2="100" stroke="black" stroke-width="2"></line>
            <polygon points="320,100 310,95 310,105" fill="black"></polygon>
            <text x="200" y="50" font-size="14" font-family="Arial">Œ¥(Fogo, a > Œ∑) ‚Üí Queimada</text>
        </svg>

        <p>Para modelar esse problema, foram utilizados valores inteiros para indicar diferentes estados e caracter√≠sticas. O 1 √© uma c√©lula de fogo, o 2 √© uma mata √∫mida, o 3 √© uma mata seca e o 0 √© uma mata completamente queimada</p>
        <p>O algoritmo para a atualiza√ß√£o dos estados de cada uma dessas c√©lulas √© muito simples: para cada c√©lula presente no grid √© chamada a fun√ß√£o update passando a c√©lula atual e seus vizinhos. Dentro dessa fun√ß√£o √© feita a soma dos vizinhos em chamas (que possuem valor 1, nesse caso) e de acordo com esse valor s√£o realizadas as transi√ß√µes.</p>

        <!-- function update(cell, neighbors) {
            const nNeighbors = neighbors.filter(val => val === 1).reduce((sum, val) => sum + val, 0);
            

            if (cell === 1)
            {
                // Fogo
                if(Math.random() > 0.98)
                {
                    // Fogo apaga e vira solo queimado
                    return 0;
                }
            }
            else if(cell === 2)
            {
                //Mata √∫mida (viva)
                if(nNeighbors * Math.random() > 2.5)//aqui
                {
                    //Come√ßa a pegar fogo
                    return 1;
                }
            }
            else if(cell === 3)
            {
                //Mata seca
                if(nNeighbors * Math.random() > 1.2) //aqui
                {
                    //Come√ßa a pegar fogo
                    return 1;
                }
            }

            return cell;
        } -->

        <p>Se voc√™ fizer alguma modifica√ß√£o no c√≥digo acima, voc√™ pode observar o impacto dessas modifica√ß√µes no quadro abaixo. Sugiro que modifique os valores de œÜ e de Œ∑ destacados pelos coment√°rios para ver o impacto dessas constantes na propaga√ß√£o do fogo pelo ambiente. </p>
        <p>A representa√ß√£o a seguir, foi implementada utilizando <a href="https://get.webgl.org/">WebGL</a> (caso ela se encontre "travada" ou finalizada, recarregue a p√°gina ou troque de navegador).</p>
        <canvas id="glcanvas" width="600" height="400"></canvas>

        <p>* Para os olhos mais atentos, <strong>œÜ</strong> na verdade n√£o √© a probabilidade da transi√ß√£o visto que ela pode assumir valores maiores do que 1. Na verdade ela √© a probabilidade de transi√ß√£o x uma constante de dificuldade de combust√£o. Quanto maior esse valor, mais c√©lulas em chamas s√£o necess√°rias para que seja poss√≠vel transitar entre mata viva e mata em chamas, dificultando o fogo de espalhar.  </p>
        
    </div>
    <script>
        // Define o tamanho da matriz
        const rows = 50;
        const cols = 50;

        let matrix = [];

        // Inicializa o WebGL
        function main() {
            const canvas = document.getElementById('glcanvas');
            canvas.width = 800;
            canvas.height = 800;
            
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
            // Define os shaders
            const vsSource = `
                attribute vec2 aVertexPosition;

                void main() {
                    gl_Position = vec4(aVertexPosition, 0.0, 1.0);
                }
            `;

            const fsSource = `
            precision mediump float;

                uniform vec4 uColor; // Cor do quadrado

                void main() {
                    gl_FragColor = uColor;
                }
            `;

            const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            gl.useProgram(shaderProgram);


            function generateMatrix() {
                matrix = Array.from({ length: rows }, () => Array(cols).fill(0));
                
                const riverWidth = 2;  // Define a largura do rio (n√∫mero de colunas ao redor da diagonal)
            
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        // Preenche a diagonal principal e as colunas pr√≥ximas a ela
                        if (Math.abs(j - i) <= riverWidth) {
                            matrix[i][j] = 4;  // Colunas na diagonal principal e pr√≥ximas a ela
                        }
                        else if (j > i) {
                            matrix[i][j] = 2;
                        }
                        // Preenche as colunas √† esquerda da diagonal principal
                        else if (j < i) {
                            matrix[i][j] = 3;
                        }


                        if (Math.abs(j - (rows - i - 1)) <= riverWidth) {
                            matrix[i][j] = 3;  // Colunas na diagonal secund√°ria e pr√≥ximas a ela
                        }
                    }
                    matrix[i][0] = 1;

                }
                


            }
            
            generateMatrix();
            animate(gl, shaderProgram);
        }

        // Fun√ß√£o para compilar shaders
        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Erro ao compilar shader: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function update(cell, neighbors) {
            const nNeighbors = neighbors.filter(val => val === 1).reduce((sum, val) => sum + val, 0);
            

            if (cell === 1)
            {
                // Fogo
                if(Math.random() > 0.98)
                {
                    // Fogo apaga e vira solo queimado
                    return 0;
                }
            }
            else if(cell === 2)
            {
                //Mata √∫mida (viva)
                if(nNeighbors * Math.random() > 2.5)
                {
                    //Come√ßa a pegar fogo
                    return 1;
                }
            }
            else if(cell === 3)
            {
                //Mata seca
                if(nNeighbors * Math.random() > 1.2)
                {
                    //Come√ßa a pegar fogo
                    return 1;
                }
            }

            return cell;
        }

        function updateMatrix(matrix) {
            let newMatrix = matrix.map(arr => [...arr]);

            for (let i = 1; i < rows - 1; i++) {
                for (let j = 1; j < cols - 1; j++) {
                    let neighbors = [
                        matrix[i-1][j-1], matrix[i-1][j], matrix[i-1][j+1],
                        matrix[i][j-1], matrix[i][j+1],
                        matrix[i+1][j-1], matrix[i+1][j], matrix[i+1][j+1]
                    ];
                    newMatrix[i][j] = update(matrix[i][j], neighbors);
                }
            }

            // Atualiza os contornos (bordas) da matriz
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    // Ignora as c√©lulas internas, j√° atualizadas
                    if (i > 0 && i < rows - 1 && j > 0 && j < cols - 1) {
                        continue;
                    }

                    // Definir vizinhos para as bordas
                    let neighbors = [];
                    if (i > 0) neighbors.push(matrix[i-1][j]); // C√©lula acima
                    if (i < rows - 1) neighbors.push(matrix[i+1][j]); // C√©lula abaixo
                    if (j > 0) neighbors.push(matrix[i][j-1]); // C√©lula √† esquerda
                    if (j < cols - 1) neighbors.push(matrix[i][j+1]); // C√©lula √† direita

                    // Atualiza as bordas com a fun√ß√£o `update`
                    newMatrix[i][j] = update(matrix[i][j], neighbors);
                }
            }
            return newMatrix;
        }


        // Fun√ß√£o de anima√ß√£o
        function animate(gl, shaderProgram) {

            const cores = [
                [0.0, 0.0, 0.0, 1.0],    // 0: Preto
                [1.0, 0.5, 0.0, 1.0],    // 1: Laranja
                [0.0, 0.5, 0.0, 1.0],    // 2: Verde
                [0.96, 0.87, 0.70, 1.0], // 3: Bege
                [0.3, 0.5, 0.8, 1.0]    //4: Azul goiaba
            ];

            
            // Limpa a tela
            gl.clearColor(0.0, 0.0, 0.0, 1.0); // Fundo preto
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            matrix = updateMatrix(matrix)
            for (let i = -24; i < 24; i++) {
                for (let j = -24; j < 24; j++) {
                    if(matrix[i+25][j+25] > 0)
                    {
                        drawSquare(gl, shaderProgram, i / 25 + 0.01, j / 25+0.01, cores[matrix[i+25][j+25]]);
                    }
                }
            }

            // Define um intervalo de 100ms (10 FPS)
            setTimeout(() => {
                requestAnimationFrame(() => animate(gl, shaderProgram));
            }, 100); // Ajuste o valor para controlar a velocidade}
        }

        function drawSquare(gl, shaderProgram, offsetX, offsetY, color) {

            console.log(`Desenhando quadrado em (${offsetX}, ${offsetY}) com cor`, color);

            const size = 0.02;
            const vertices = new Float32Array([
                -size + offsetX,  size + offsetY,
                -size + offsetX, -size + offsetY,
                size + offsetX, -size + offsetY,
                size + offsetX,  size + offsetY
            ]);

            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const vertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
            gl.enableVertexAttribArray(vertexPosition);
            gl.vertexAttribPointer(vertexPosition, 2, gl.FLOAT, false, 0, 0);

            const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            // üî• Define a cor antes de desenhar
            const colorLocation = gl.getUniformLocation(shaderProgram, 'uColor');
            gl.uniform4f(colorLocation, color[0], color[1], color[2], color[3]); // RGBA

            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }


        main();

    </script>
</body>
</html>
